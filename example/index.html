<!DOCTYPE html>
<html lang="en">
<head>
<title>Reticulum | Basic VR Example</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style type="text/css">
	html, body {
		background-color: #000;
		margin: 0;
		padding: 0; 
		overflow: hidden;
	}
</style>
</head>

<body>

<script src="./js/lib/three.dev.js?abcdefghij"></script>
<!--script src="./js/vr/PhoneVR.js?abcdefgh"></script-->
<script src="./js/vr/VRControls.js?abcdefghij"></script>
<script src="./js/vr/VREffect.js?abcdefghij"></script>

<script src="./js/vr/webvr-polyfill.js?abcdefghij"></script>
<script src="./js/vr/webvr-manager.js?abcdefghij"></script>


<script src="../reticulum.js?abcdefghijklmn"></script>



<script>
CARDBOARD_DEBUG = false;
// Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
// Append the canvas element created by the renderer to document body element.
document.body.appendChild( renderer.domElement );

//Create a three.js scene
var scene = new THREE.Scene();

//Create a three.js camera
//var camera = new THREE.PerspectiveCamera( 110, window.innerWidth / window.innerHeight, 2, 10000 );
//scene.add(camera);
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.3, 10000);
//Apply VR headset positional data to camera.
var controls = new THREE.VRControls( camera );

//Apply VR stereo rendering to renderer
var effect = new THREE.VREffect( renderer );
effect.setSize( window.innerWidth, window.innerHeight );

// Create a VR manager helper to enter and exit VR mode.
var manager = new WebVRManager( renderer, effect, {hideButton: false} );



var hemiLight = new THREE.HemisphereLight(0x0000ff, 0x00ff00, 0.6);
hemiLight.position.set(0, 500, 0);
scene.add(hemiLight);
var boxGeometry = new THREE.BoxGeometry( 20, 20, 20 );
var planeGeometry = new THREE.PlaneGeometry( 20, 20 );
var sphereGeometry = new THREE.SphereGeometry( 10, 6, 1 );

//Boxes, Planes and spheres
for ( var i = 0; i < 750; i ++ ) {
	addMesh(boxGeometry);
	addMesh(planeGeometry);
	addMesh(sphereGeometry);
}



function addMesh(geo) {

	var object = new THREE.Mesh( geo, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

	object.position.x = Math.random() * 1200 - 400;
	object.position.y = Math.random() * 1200 - 400;
	object.position.z = Math.random() * 1200 - 400;

	//object.rotation.y = Math.random() * 360;

	
	// *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	object.ongazeover = function(){
		this.material.emissive.setHex( 0xffcc00 );
	}
	// have the object react when user looks away from it
	object.ongazeout = function(){
		this.material.emissive.setHex( 0xcc0000 );
	}
	// have the object react when user looks at it for a specific time
	object.ongazelong = function(){
		this.material.emissive.setHex( 0x0000cc );
	}

	// track the object
	Reticulum.addCollider(object);

	scene.add( object );

}


// *******************************
// --- Reticulum ---
// initiate Reticulum so it loads up 
Reticulum.init(camera, {
	gazingDuration: 2.5,
	reticle: {
		far: 1000,
		visible: true,
		color: 0xcc0000,
		radius: 0.005,
		tube: 0.001
	}
});

// IMPORTANT add camera to cene if you want to see a reticle 
scene.add(camera);






function animate() {
	
	requestAnimationFrame(animate);

	// *******************************
	// --- Reticulum ---
	// keep checking if user is looking at any tracked objects
	Reticulum.loop();

	controls.update();
	manager.render(scene, camera);


	
}
animate();



/*
Listen for keyboard events
*/
// Reset the position sensor when 'z' pressed.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.resetSensor();
  }
};

/*
Handle window resizes
*/
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  effect.setSize( window.innerWidth, window.innerHeight );
}
window.addEventListener( 'resize', onWindowResize, false );
</script>
</body>
</html>